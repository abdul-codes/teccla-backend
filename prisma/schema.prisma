generator client {
  provider = "prisma-client"
  output   = "./generated/prisma"
}

datasource db {
  provider = "postgresql"
 // url      = env("TEST_DATABASE_URL")
}

model OtpVerification {
  id      String   @id @default(cuid())
  otp     String   @unique
  expires DateTime
  userId  String
  User    User     @relation(fields: [userId], references: [id])

  @@unique([userId, otp])
}

model OtpAttempts {
  id       String   @id @default(cuid())
  attempts Int      @default(0)
  lastTry  DateTime @default(now())
  userId   String   @unique
  User     User     @relation(fields: [userId], references: [id])
}

model RefreshToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())
  revoked   Boolean  @default(false)
  User      User     @relation(fields: [userId], references: [id])
}

model Asset {
  id           String    @id @default(cuid())
  url          String
  publicId     String
  assetType    AssetType
  format       String
  bytes        String
  width        String
  height       String
  uploadedById String
  projectId    String
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  project      Project   @relation(fields: [projectId], references: [id], onDelete: Cascade)
  uploadedBy   User      @relation(fields: [uploadedById], references: [id])

  @@index([projectId])
  @@index([assetType])
}

model Project {
  id          String        @id @unique @default(cuid())
  title       String        @unique
  description String
  location    String
  budget      Float
  type        String
  status      ProjectStatus
  startDate   DateTime?
  finishDate  DateTime?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  createdById String
  asset       Asset[]
  createdBy   User          @relation(fields: [createdById], references: [id])
}

model User {
  id                       String                    @id @unique @default(cuid())
  email                    String                    @unique
  phoneNumber              String?                   @unique
  password                 String
  firstName                String
  lastName                 String
  profilePicture           String?
  role                     UserRole                  @default(USER)
  companyName              String?
  companyRole              String?
  address                  String?
  city                     String?
  state                    String?
  country                  String?
  createdAt                DateTime                  @default(now())
  updatedAt                DateTime                  @updatedAt
  lastLogin                DateTime?
  loginAttempts            Int                       @default(0)
  emailVerified            DateTime?
  userAccountId            String?                   @unique
  assets                   Asset[]
  createdConversations     Conversation[]            @relation("ConversationCreator")
  conversationParticipants ConversationParticipant[]
  sentMessages             Message[]                 @relation("MessageSender")
  receivedMessageReads     MessageRead[]
  OtpAttempts              OtpAttempts?
  OtpVerification          OtpVerification[]
  projects                 Project[]
  RefreshTokens            RefreshToken[]
  subscription             Subscription?


  @@index([email, role, userAccountId])
}

model Conversation {
  id           String                    @id @default(cuid())
  name         String?
  description  String?
  isGroup      Boolean                   @default(false)
  avatar       String?
  createdBy    String
  createdAt    DateTime                  @default(now())
  updatedAt    DateTime                  @updatedAt
  creator      User                      @relation("ConversationCreator", fields: [createdBy], references: [id])
  participants ConversationParticipant[]
  messages     Message[]

  @@index([createdBy])
  @@index([isGroup])
  @@index([createdAt])
}

model ConversationParticipant {
  id             String          @id @default(cuid())
  conversationId String
  userId         String
  role           ParticipantRole @default(MEMBER)
  joinedAt       DateTime        @default(now())
  lastReadAt     DateTime        @default(now())
  isMuted        Boolean         @default(false)
  conversation   Conversation    @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user           User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  messageReads   MessageRead[]

  @@unique([conversationId, userId])
  @@index([userId])
  @@index([conversationId])
  @@index([userId, conversationId])
}

model Message {
  id             String        @id @default(cuid())
  conversationId String
  senderId       String
  content        String
  messageType    MessageType   @default(TEXT)
  replyToId      String?
  attachmentUrl  String?
  attachmentType String?
  attachmentName String?
  isEdited       Boolean       @default(false)
  editedAt       DateTime?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  conversation   Conversation  @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  replyTo        Message?      @relation("MessageReply", fields: [replyToId], references: [id])
  replies        Message[]     @relation("MessageReply")
  sender         User          @relation("MessageSender", fields: [senderId], references: [id])
  messageReads   MessageRead[]

  @@index([conversationId, createdAt(sort: Desc)])
  @@index([senderId])
  @@index([replyToId])
}

model MessageRead {
  id            String                  @id @default(cuid())
  messageId     String
  userId        String
  participantId String
  readAt        DateTime                @default(now())
  message       Message                 @relation(fields: [messageId], references: [id], onDelete: Cascade)
  participant   ConversationParticipant @relation(fields: [participantId], references: [id], onDelete: Cascade)
  user          User                    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId])
  @@index([messageId])
  @@index([userId])
  @@index([participantId])
  @@index([userId, messageId])
}

model Subscription {
  id  String @id @default(cuid())
  userId String  @unique
  createdAt               DateTime          @default(now())
  updatedAt               DateTime          @updatedAt
  user                    User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  payments                Payment[]

  @@index([userId])
  @@index([paystackCustomerCode])
  @@index([status])

}

model Payment {
  id                 String        @id @default(cuid())
  subscriptionId     String    
  currency           String        @default("NGN")
  status             PaymentStatus
  channel            String?       // card, bank, ussd, etc.
  cardType           String?       // visa, mastercard, verve
  bank               String?       // For bank transfers
  description        String?
  paidAt             DateTime?
  createdAt          DateTime      @default(now())
  paystackReference  String        @unique
  subscription       Subscription @relation(fields:[subscriptionId], references: [id], onDelete: Cascade)
}

enum UserRole {
  ADMIN
  USER
}

enum ProjectStatus {
  PLANNING
  IN_PROGRESS
  COMPLETED
}

enum AssetType {
  IMAGE
  DOCUMENT
  VIDEO
  OTHER
}

enum ParticipantRole {
  ADMIN
  MODERATOR
  MEMBER
}

enum MessageType {
  TEXT
  IMAGE
  DOCUMENT
  VIDEO
  AUDIO
  SYSTEM
}

enum SubscriptionStatus {
  ACTIVE
  INACTIVE
  NON_RENEWING  // Canceled but still valid until period end
  ATTENTION     // Payment failed, needs attention
  COMPLETED     // Subscription ended
}

enum PaymentStatus {
  SUCCESS
  PENDING
  FAILED
  ABANDONED
  REVERSED
}